/*-----------------------------------------------------------------

__/\\\\\\\\\\\\\ _____/\\\\\\\\\ _______/\\../\\ ___/\\\\\\\\\\\\\\\        
 _\/\\\/////////\\\ _/\\\///////\\\ ____\//..\//____\/\\\///////////__       
  _\/\\\.......\/\\\.\/\\\.....\/\\\ ________________\/\\\ ____________      
   _\/\\\\\\\\\\\\\/__\/\\\\\\\\\\\/_____/\\\____/\\\.\/\\\\\\\\\\\ ____     
    _\/\\\/////////____\/\\\//////\\\ ___\/\\\___\/\\\.\/\\\///////______    
     _\/\\\ ____________\/\\\ ___\//\\\ __\/\\\___\/\\\.\/\\\ ____________   
      _\/\\\ ____________\/\\\ ____\//\\\ _\/\\\___\/\\\.\/\\\ ____________  
       _\/\\\ ____________\/\\\ _____\//\\\.\//\\\\\\\\\ _\/\\\ ____________ 
        _\/// _____________\/// _______\/// __\///////// __\/// _____________



██████╗ ██████╗  █   █  ███████╗
██╔══██╗██╔══██╗        ██╔════╝
██████╔╝██████╔╝██╗  ██╗█████╗  
██╔═══╝ ██╔══██╗██║  ██║██╔══╝  
██║     ██║  ██║╚█████╔╝██║     
╚═╝     ╚═╝  ╚═╝╚═════╝ ╚═╝     

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.6.7;

/*-----------------------------------------------------------------
 *TO DO :
 *
 *      *Design Json templates for IPFS1 and IPFS2
 *
 *      *Above 65k segregation (probably by ACinfo custodial type) (just need to add a wild west contract?)
 *
 *      *find a way to find and react to assets being in a dead asset class (future, API verified, works w/ AC0)
 *
 *      *what do we do (if anything) with the 128 "free" bits in the storage struct?
 *
 *      *make "pruf verify" contract, stores ipfs? with list of "held" assets?
 *
 *      *identify funtionality in core contracts that needs to be killable
 *
 *      *finish pricing model and paymentSharing based on holding pruf tokens. (paid to PRUF) 
 *
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 *Rules for reminting tokens:
 *  must have the plaintext that generates the rgtHash on-chain
 *
 *
 *Rules for burning records: 
 *  record is locked in escrow and the escrow contract gets the token. The asset is put into an indefinite escrow, 
 *  where the escrow amount is unpaid and time is indefinite. the asset owner is the escrow "holder" and can revert
 *  the escrow if they desire, which reverts the assetToken to their address. escrow amount is determined 
 *  AT THE TIME OF RECYCLING by the new record costs of the AC that the record is being recycled into by
 *  the new owner.
 *
 *
 * Rules for recycling records:
 *  escrow amount is the same as registration in the asset class where it will be registered (as per the "recycle asset" call),
 *  when the fee is paid the escrow is broken, and the asset token is assigned to the sender. The funds (less assetClassRoot fees)
 *  are divided 50/50 between the old owner (setter of the escrow) and the ACtoken holder for the new asset class. If funds are sent 
 *  to a dead escrow or there is an overpayment, the balance can be withdrawn.
 *
 *
 * Escrows with escrow.data > 199 cannot be ended by permissive end escrow (escrowmanager) 
 *   and must be ended only within their respective escrow contract.
 *
 *
 *  Recycle rules
 *          Not possible in Custodial asset classes
 *          Caller must hold token, must be in status 59
 *          Token goes into "indefinite" escrow, RGT set to 0xFFF...
 *              Caller is escrow controller, but escrow contract is "owner", can break escrow (resets to status 51)
 *              Price set when escrow is to be broken by reregistering, from costs of the category 
 *                     that it is to be imported into (endEscrow called from T_PRUF_APP?)
 *              Importing breaks the escrow
 *                  payment divided between ACroot, ACholder, and recycling address (escrow owner)     
 *                  token sent to new owner (payment sender), status set to 51
 *
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * FUTURE FEATURES?
 *      "bottle deposit" on asset creation to encourage recycling
 *  New Recycle :
 *          Not possible in Custodial asset classes
 *          Caller must hold token, must be in status 59
 *          Caller recieves deposit amount (how the bloody hell do we manage this????)
 *          Token goes into "indefinite" escrow, RGT set to 0xFFF...
 *              Caller is escrow controller, but escrow contract is "owner", can break escrow 
 *                      (requires repayment of deposit amount, resets to status 51)
 *              Price set when escrow is to be broken by reregistering, from costs of the category 
 *                     that it is to be imported into (endEscrow called from T_PRUF_APP?)
 *              Importing breaks the escrow
 *                  payment divided between ACroot, ACholder, and recycling address (escrow owner)     
 *                  token sent to new owner (payment sender), status set to 51
 *
 *
 *
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * NOTES 
 * All assetclasses in the same root should use the same data structure to generate the idxHash. Other structures 
 *     will result in a nonconforming "hidden" asset only findable in its own web interface, and not AC transportable.
 * When upgrading a contract, all authorized asset classes will be linked to the name, not the newly deplyed contract address
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * IMPORTANT NOTE : DO NOT REMOVE FROM CODE:
 *      Verification of rgtHash in curated, custodial asset classes are not secure beyond the honorable intentions
 * of authorized recorders. All blockchain info is readable, so a bad actor could trivially obtain a copy of the
 * correct rgtHash on chain. This "stumbling block" measure is in place primarily to keep honest people honest, and
 * to require an actual, malicious effort to bypass security rather than a little copy-paste. Actual decentralized
 * security is provided with tokenized assets, which do not rely on the coercive trust relationship that creates the
 * incentive for recorders not to engage in malicious practices.
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * Order of require statements:
 * 1: (modifiers)
 * 2: checking custodial status
 * 3: checking the asset existance 
 * 4: checking the idendity and credentials of the caller
 * 5: checking the suitability of provided data for the proposed operation
 * 6: checking the suitability of asset details for the proposed operation
 * 7: verifying that provided verification data matches required data
 * 8: verifying that message contains any required payment
 *
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * Contract Resolution Names -
 *  A_TKN - 1
 *  AC_TKN - 1
 *  ID_TKN - 10
 *
 *  APP - 1
 *  NP - 1
 *  APP_NC - 2
 *  NP_NC - 2
 *
 *  ECR - 3
 *  ECR_NC - 3
 *  RCLR - 3
 *
 *  ECR_MGR - 1
 *  AC_MGR - 1
 *  VFY - 1 ????
 *
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * CONTRACT Types:  contractAdresses (storage)
 * -----------------  AC0 is a flag for a contract being a pruf authorized contract, in general
 * 0   --Not Authorized
 * 1   --Authorized Contract for CUSTODIAL assets (contract will create assets with custodial assetStatus 0)
 * 2   --Authorized Contract for NON_CUSTODIAL assets (contract will create assets with custodial assetStatus 51)
 * 3   --Escrow contracts, Recycler (contracts authorized for ECR-MGR management)
 * 10  --Pruf contracts with no specific permissions, but still trusted
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * ASSET CLASS Types: AC_data.custodyType (AC_manager)
 * 0   --NONE
 * 1   --Custodial
 * 2   --Non-Custodial
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * Authorized User Types, per AC
 * -----------------  AC0 stores an count on the number of AC's a gicen addressHash is registered in
 * 0 = NO AUTHORIZATIONS
 * 1 - 4 = Standard User types
 * 1 - all priveleges
 * 2 - all but force-modify
 * 5 - 9 = Robot (cannot create or force-modify)
 * 10 = issue naked assets only
 * Other = no internal authorizations, but can be used by external functions
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * Record status field key
 *
 * 0 = no status, Non transferrable. Default asset creation status
 *       default after FMR, and after status 5 (essentially a FMR) (IN frontend)
 * 1 = transferrable
 * 2 = nontransferrable
 * 3 = stolen
 * 4 = lost
 * 5 = transferred but not reImported (no new rghtsholder information) implies that asset posessor is the owner. (discarded)
 *       must be re-imported by ACadmin through regular onboarding process
 *       no actions besides modify RGT to a new rightsholder can be performed on a statuss 5 asset (no status changes) (Frontend)
 * 6 = in supervised escrow, locked until timelock expires, but can be set to lost or stolen
 *       Status 1-6 Actions cannot be performed by automation.
 *       only ACAdmins can set or unset these statuses, except 5 which can be set by automation
 * 7 = out of Supervised escrow (user < 5)
 *
 * 50 Locked escrow
 * 51 = transferrable, automation set/unset (secret confirmed)(ACAdmin can unset)
 * 52 = non-transferrable, automation set/unset (secret confirmed)(ACAdmin can unset)
 * 53 = stolen (automation set)(ONLY ACAdmin can unset)
 * 54 = lost (automation set/unset)(ACAdmin can unset)             
 * 55 = asset transferred automation set/unset (secret confirmed)(Only ACAdmin can unset) (discarded) ####DO NOT USE????
                ^^!!!CANNOT BE SET BY CURRENT CONTRACTS 8/13/2020!!!^^
 * 56 = escrow - automation set/unset (secret confirmed)(ACAdmin can unset)
 * 57 = out of escrow
 * 58 = out of locked escrow
 * 59 = Discardable
 * 60 = Recyclable (can only be reimported by an ACAdmin) (discarded)
 * 70 = Importable(Exported)
 *
*-----------------------------------------------------------------

*-----------------------------------------------------------------
 * ----------SETUP PROCEDURES---------- *
 * need at least 3 Eth adressses
 * 1: Deploy Contracts
 * 2: Add contracts @ respective name in storage, use assetclass 0
 * 3: Resolve token contract addresses
 * 4: Set storage contract in each contract
 * 5: Mint 2 root asset tokens. (home, foreign) !(CustodyType 3)!
 * 6: Mint 2 cust and 2 non-custodial assetclasses in the home assetclass
 * 7: Mint 1 cust and 1 non-custodial assetclasses in the foreign assetclass 
 * 8: Authorize contracts @ respective names in storage using existing assetclasses 
 *      -- type 1 for custodial, type 2 for non-custodial. Authorize asset token contract as type 1 in all root asset classes.
 * 9: Resolve Contract Addresses
 * 10: Set costs / users / types for root && rooted AC token
 * 11: THE WORKS
 *
*-----------------------------------------------------------------

Round robin test pattern:

1: Create an asset as non-custodial naked asset
2: claim the asset
3: try to claim again (fail)
4: add IPFS2 note
5: add IPFS2 note again (fail)
6: 





sec tok ideas

beancoin style - 1 token = 1 share
disadvantage is that each share must be redeemed separately, so higher gas costs

escrow style - sends tokens to escrow, escrow holds until escrow is up, then returns tokens and authorizes the address for funds.

special escrow-send tokens:
        creates a mapping of address to quantity of tokens.
        address that is used casnot be overwritten.
        escrow ends every 1000 blocks (starts at arbitrary time)
end escrow after escrow end block passes (all escrows end at the same time) (caller must be setter)
        sends tokens back to caller
        authorizes the fractional share of that (AND ONLY THAT) end blocks takings to the caller adress (IF YOU MISS ONE, THATS ON YOU)



*/
